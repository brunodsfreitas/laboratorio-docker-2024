# Configuration for telegraf agent
[agent]
  ## Default data collection interval for all inputs
  interval = "3s"
  ## Rounds collection interval to 'interval'
  ## ie, if interval="10s" then always collect on :00, :10, :20, etc.
  round_interval = true

  ## Telegraf will send metrics to outputs in batches of at most
  ## metric_batch_size metrics.
  ## This controls the size of writes that Telegraf sends to output plugins.
  metric_batch_size = 100000

  ## For failed writes, telegraf will cache metric_buffer_limit metrics for each
  ## output, and will flush this buffer on a successful write. Oldest metrics
  ## are dropped first when this buffer fills.
  ## This buffer only fills when writes fail to output plugin(s).
  metric_buffer_limit = 1000000

  ## Collection jitter is used to jitter the collection by a random amount.
  ## Each plugin will sleep for a random time within jitter before collecting.
  ## This can be used to avoid many plugins querying things like sysfs at the
  ## same time, which can have a measurable effect on the system.
  collection_jitter = "0s"

  ## Default flushing interval for all outputs. Maximum flush_interval will be
  ## flush_interval + flush_jitter
  flush_interval = "10s"
  ## Jitter the flush interval by a random amount. This is primarily to avoid
  ## large write spikes for users running a large number of telegraf instances.
  ## ie, a jitter of 5s and interval 10s means flushes will happen every 10-15s
  flush_jitter = "0s"

  ## By default or when set to "0s", precision will be set to the same
  ## timestamp order as the collection interval, with the maximum being 1s.
  ##   ie, when interval = "10s", precision will be "1s"
  ##       when interval = "250ms", precision will be "1ms"
  ## Precision will NOT be used for service inputs. It is up to each individual
  ## service input to set the timestamp at the appropriate precision.
  ## Valid time units are "ns", "us" (or "µs"), "ms", "s".
  precision = ""

  ## Logging configuration:
  ## Run telegraf with debug log messages.
  debug = true
  ## Run telegraf in quiet mode (error log messages only).
  quiet = false
  ## Specify the log file name. The empty string means to log to stderr.
  logfile = "/tmp/logtelegraf"

  ## Override default hostname, if empty use os.Hostname()
  hostname = "AlienWare-X"
  ## If set to true, do no set the "host" tag in the telegraf agent.
  omit_hostname = false
[[outputs.influxdb_v2]]	
  ## The URLs of the InfluxDB cluster nodes.
  ##
  ## Multiple URLs can be specified for a single cluster, only ONE of the
  ## urls will be written to each interval.
  ## urls exp: http://127.0.0.1:8086
  urls = ["http://influxdb:8086"]

  ## Token for authentication.
  token = "${DOCKER_INFLUXDB_INIT_ADMIN_TOKEN}"
  
  ## Organization is the name of the organization you wish to write to; must exist.
  organization = "${DOCKER_INFLUXDB_INIT_ORG}"
  
  ## Destination bucket to write into.
  bucket = "${DOCKER_INFLUXDB_INIT_BUCKET}"

  insecure_skip_verify = true

[[inputs.cpu]]
  ## Whether to report per-cpu stats or not
  percpu = true
  ## Whether to report total system cpu stats or not
  totalcpu = true
  ## If true, collect raw CPU time metrics.
  collect_cpu_time = false
  ## If true, compute and report the sum of all non-idle CPU states.
  report_active = false
[[inputs.disk]]
  ## By default stats will be gathered for all mount points.
  ## Set mount_points will restrict the stats to only the specified mount points.
  # mount_points = ["/"]
  ## Ignore mount points by filesystem type.
  ignore_fs = ["tmpfs", "devtmpfs", "devfs", "overlay", "aufs", "squashfs"]
[[inputs.diskio]]
[[inputs.mem]]
[[inputs.net]]
[[inputs.processes]]
[[inputs.swap]]
[[inputs.system]]


[[inputs.http]]
  name_override = "xml_data"
  urls = ["https://raw.githubusercontent.com/clojure/data.xml/master/pom.xml"] # Substitua pela URL do arquivo XML
  data_format = "xml"

[[inputs.http_response]]
  name_override = "xml_check"
  address = "https://www.google.com.br" # Substitua pela URL que deseja verificar
  response_timeout = "5s" # Tempo limite para aguardar a resposta (opcional)
  method = "GET" # Método da requisição (padrão: GET)
  # Se necessário, adicione headers ou outros parâmetros aqui

#[[inputs.http]]
#  name_override = "xml_data2"
#  urls = ["https://raw.githubusercontent.com/brunodsfreitas/html-repo-example/master/example-xml"] # Substitua pela URL do arquivo XML
#  data_format = "xml"

#[inputs.http.tags]
#  source = "iot_data_tag" # Adicione tags se necessário

#[[inputs.http.xml]]
#  measurement = "wifi_data"
#  fields = [
#    { name = "wifi_essid", xpath = "/sys/wifi_essid" },
#    { name = "wifi_psk", xpath = "/sys/wifi_psk" },
#   { name = "wifi_ip", xpath = "/sys/wifi_ip" },
#    { name = "wifi_gateway", xpath = "/sys/wifi_gateway" }
#  ]

[[inputs.http]]
  name_override = "xml_data3"
  urls = ["https://raw.githubusercontent.com/brunodsfreitas/html-repo-example/master/example-xml"]
  data_format = "xml"

  [[inputs.http.xml]]
    metric_name = "'sys'"
    metric_selection = "/sys"

    [inputs.http.xml.tags]
      wifi = "/sys/wifi"

    [inputs.http.xml.fields]
      wifi_ip = "string(wifi/wifi_ip)"
      wifi_psk = "string(wifi/wifi_psk)"
  
  #[[inputs.http.xml]]
  #  xpath = "/sys/wifi/wifi_ip"  # Ajuste o caminho XPath para refletir a estrutura correta do XML
  #  field = "wifi_ip"

[[inputs.http]]
  name_override = "iot_sys_data"
  urls = ["https://raw.githubusercontent.com/brunodsfreitas/html-repo-example/master/example-xml"]
  data_format = "xml"

  [[inputs.http.xml]]
    metric_name = "'sys'"
    metric_selection = "/sys"

    [inputs.http.xml.tags]
    ip_cable = "/sys/ip"
    netmask_cable = "/sys/netmask"
    gateway_cable = "/sys/gateway"
    mac_cable = "/sys/mac"
    dhcp_enable_cable = "/sys/dhcp_enable"
    #g4_dev_exist = "/sys/g4_dev_exist"
    wifi_dev_exist = "/sys/wifi_dev_exist"
    wifi_enable = "/sys/wifi_enable"
    wifi_ap_mode = "/sys/wifi_ap_mode"
    wifi_hostap_essid = "/sys/wifi_hostap_essid"
    #wifi_hostap_psk = "/sys/wifi_hostap_psk"
    wifi_hostap_channel = "/sys/wifi_hostap_channel"
    dns0 = "/sys/dns0"
    dns1 = "/sys/dns1"
    http_port = "/sys/http_port"
    rtsp_port = "/sys/rtsp_port"
    #rtsp_g711 = "/sys/rtsp_g711"
    #rtsp_g711_8k = "/sys/rtsp_g711_8k"
    #rtsp_g711_mu = "/sys/rtsp_g711_mu"
    #audio_left_right = "/sys/audio_left_right"
    ts_over_rtsp = "/sys/ts_over_rtsp"
    rtp_multicast = "/sys/rtp_multicast"
    #udp_ttl = "/sys/udp_ttl"
    #udp_sock_buf_size = "/sys/udp_sock_buf_size"
    #html_password = "/sys/html_password"
    hostname = "/sys/hostname"
    #language = "/sys/language"

  #[[inputs.http.xml]]
    #xpath = "/sys/wifi"
    #field = "wifi"

    #[inputs.http.xml.tags]
      #wifi_id = "id"

    [inputs.http.xml.fields]
      wifi_essid = "string(wifi_essid)"
      #wifi_psk = "string(wifi_psk)"
      wifi_ip = "string(wifi_ip)"
      wifi_netmask = "string(wifi_netmask)"
      wifi_gateway = "string(wifi_gateway)"
      wifi_dhcp_enable = "string(wifi_dhcp_enable)"


[[inputs.exec]]
  name_override = "script_iot_status_data"
  commands = ["/tmp/xml_parser.py"]  # Substitua pelo caminho do seu script
  timeout = "5s"
  data_format = "influx"

[[inputs.http]]
  name_override = "iot6_status_data"
  urls = ["https://raw.githubusercontent.com/brunodsfreitas/html-repo-example/master/getstatus264"]
  data_format = "xml"

  [[inputs.http.xml]]
    metric_name = "'status'"
    metric_selection = "/status"

    [inputs.http.xml.tags]
    ssid_ = "/status/wifi/ssid"
    ip_ = "/status/wifi/ip"
    version_ = "/status/version"
    width_ = "/status/@venc/width"
    height_ = "/status/@venc/height"
    framerate_ = "/status/@venc/framerate"

    [inputs.http.xml.fields]
    _data_ = "number(version)"

[[inputs.http]]
  name_override = "FULL-XML"
  urls = ["https://raw.githubusercontent.com/brunodsfreitas/html-repo-example/master/getstatus264"]
  method = "GET"
  data_format = "xml"

[[inputs.exec]]
  command = "seu_script_de_processamento.sh" # Substitua pelo caminho do seu script de processamento do XML
  timeout = "5s" # Defina um timeout para a execução do script, se necessário
  data_format = "influx"
  name_override = "xml_data" # Nome do plugin HTTP para vincular com o output para InfluxDB
  tag_keys = ["tags"] # Chaves para as tags no InfluxDB
  tag_values = ["values"] # Valores correspondentes para as tags no InfluxDB
